/**
 * Automated Security Scanning and Vulnerability Detection System
 * Provides comprehensive security analysis and vulnerability management
 */

const { EventEmitter } = require('events');
const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');
const crypto = require('crypto');

class VulnerabilityScanner extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = {
      // Scanning intervals
      scanInterval: config.scanInterval || 24 * 60 * 60 * 1000, // Daily
      quickScanInterval: config.quickScanInterval || 60 * 60 * 1000, // Hourly
      deepScanInterval: config.deepScanInterval || 7 * 24 * 60 * 60 * 1000, // Weekly

      // Scan settings
      scanDepth: config.scanDepth || 'deep',
      enableStaticAnalysis: config.enableStaticAnalysis !== false,
      enableDependencyScan: config.enableDependencyScan !== false,
      enableSecretsScan: config.enableSecretsScan !== false,
      enableInfrastructureScan: config.enableInfrastructureScan || false,

      // Vulnerability thresholds
      severityThresholds: config.severityThresholds || {
        critical: 0,
        high: 0,
        medium: 5,
        low: 10
      },

      // Reporting
      enableReporting: config.enableReporting !== false,
      reportFormat: config.reportFormat || 'json',
      reportRetention: config.reportRetentionDays || 30,

      // Automated response
      enableAutoRemediation: config.enableAutoRemediation || false,
      autoPatchCritical: config.autoPatchCritical || false,
      quarantineVulnerableFiles: config.quarantineVulnerableFiles || false,

      ...config
    };

    this.scanHistory = [];
    this.vulnerabilityDatabase = new Map();
    this.scanMetrics = {
      totalScans: 0,
      vulnerabilitiesFound: 0,
      criticalIssuesFound: 0,
      scansCompleted: 0,
      scansFailed: 0,
      averageScanTime: 0
    };

    this.initializeScanner();
  }

  /**
   * Initialize vulnerability scanner
   */
  async initializeScanner() {
    try {
      // Load vulnerability database
      await this.loadVulnerabilityDatabase();

      // Setup scan schedules
      this.setupScanSchedules();

      // Initialize scanning engines
      await this.initializeScanningEngines();

      // Load known vulnerabilities
      await this.loadKnownVulnerabilities();

      console.log('ðŸ” Vulnerability Scanner initialized');
      console.log(`ðŸ“Š Scan depth: ${this.config.scanDepth}`);
      console.log(`â° Scan interval: ${this.config.scanInterval / 1000 / 60 / 60} hours`);

    } catch (error) {
      console.error('âŒ Failed to initialize Vulnerability Scanner:', error);
      throw error;
    }
  }

  /**
   * Run comprehensive security scan
   */
  async runComprehensiveScan(projectPath = '.') {
    const scanId = this.generateScanId();
    const startTime = Date.now();

    try {
      const scan = {
        id: scanId,
        timestamp: new Date().toISOString(),
        projectPath,
        type: 'comprehensive',
        status: 'SCANNING',
        results: {},
        summary: {}
      };

      console.log(`ðŸ” Starting comprehensive security scan: ${scanId}`);

      // 1. Static code analysis
      if (this.config.enableStaticAnalysis) {
        scan.results.staticAnalysis = await this.performStaticAnalysis(projectPath);
      }

      // 2. Dependency vulnerability scanning
      if (this.config.enableDependencyScan) {
        scan.results.dependencies = await this.scanDependencies(projectPath);
      }

      // 3. Secrets detection
      if (this.config.enableSecretsScan) {
        scan.results.secrets = await this.scanForSecrets(projectPath);
      }

      // 4. Infrastructure scanning
      if (this.config.enableInfrastructureScan) {
        scan.results.infrastructure = await this.scanInfrastructure(projectPath);
      }

      // 5. Configuration security scanning
      scan.results.configuration = await this.scanConfiguration(projectPath);

      // 6. API endpoint scanning
      scan.results.apiEndpoints = await this.scanApiEndpoints(projectPath);

      // 7. Database security scanning
      scan.results.database = await this.scanDatabase(projectPath);

      // 8. File system security scanning
      scan.results.fileSystem = await this.scanFileSystem(projectPath);

      // 9. Network security scanning
      scan.results.network = await this.scanNetworkSecurity(projectPath);

      // 10. Custom security rules
      scan.results.customRules = await this.applyCustomSecurityRules(projectPath);

      // Calculate scan summary
      scan.summary = await this.calculateScanSummary(scan.results);
      scan.duration = Date.now() - startTime;

      // Update status
      scan.status = 'COMPLETED';

      // Store scan results
      await this.storeScanResults(scan);

      // Update metrics
      this.updateScanMetrics(scan);

      // Generate report
      if (this.config.enableReporting) {
        await this.generateScanReport(scan);
      }

      // Handle critical vulnerabilities
      await this.handleCriticalVulnerabilities(scan);

      console.log(`âœ… Security scan completed: ${scanId}`);
      console.log(`ðŸ“Š Vulnerabilities found: ${scan.summary.totalVulnerabilities}`);
      console.log(`ðŸš¨ Critical issues: ${scan.summary.criticalIssues}`);

      // Emit scan completed event
      this.emit('scanCompleted', scan);

      return scan;

    } catch (error) {
      console.error(`âŒ Security scan failed:`, error);

      const failedScan = {
        id: scanId,
        timestamp: new Date().toISOString(),
        projectPath,
        type: 'comprehensive',
        status: 'FAILED',
        error: error.message,
        duration: Date.now() - startTime
      };

      await this.storeScanResults(failedScan);
      this.scanMetrics.scansFailed++;

      throw error;
    }
  }

  /**
   * Perform static code analysis
   */
  async performStaticAnalysis(projectPath) {
    const analysis = {
      engines: [],
      vulnerabilities: [],
      metrics: {},
      duration: 0
    };

    try {
      const startTime = Date.now();

      // ESLint security rules
      analysis.engines.push(await this.runESLintSecurityScan(projectPath));

      // Semgrep security scanning
      analysis.engines.push(await this.runSemgrepScan(projectPath));

      // CodeQL analysis (if available)
      analysis.engines.push(await this.runCodeQLScan(projectPath));

      // SonarQube analysis (if configured)
      analysis.engines.push(await this.runSonarQubeScan(projectPath));

      // Aggregate results
      for (const engine of analysis.engines) {
        if (engine.vulnerabilities) {
          analysis.vulnerabilities.push(...engine.vulnerabilities);
        }
      }

      // Calculate metrics
      analysis.metrics = {
        totalEngines: analysis.engines.length,
        totalVulnerabilities: analysis.vulnerabilities.length,
        severityBreakdown: this.calculateSeverityBreakdown(analysis.vulnerabilities),
        fileCoverage: await this.calculateFileCoverage(projectPath)
      };

      analysis.duration = Date.now() - startTime;

    } catch (error) {
      analysis.error = error.message;
    }

    return analysis;
  }

  /**
   * Scan for dependencies vulnerabilities
   */
  async scanDependencies(projectPath) {
    const dependencyScan = {
      packageManagers: [],
      vulnerabilities: [],
      metrics: {},
      duration: 0
    };

    try {
      const startTime = Date.now();

      // npm audit
      dependencyScan.packageManagers.push(await this.runNpmAudit(projectPath));

      // yarn audit (if yarn.lock exists)
      if (await this.fileExists(path.join(projectPath, 'yarn.lock'))) {
        dependencyScan.packageManagers.push(await this.runYarnAudit(projectPath));
      }

      // pip audit (if Python dependencies)
      if (await this.fileExists(path.join(projectPath, 'requirements.txt'))) {
        dependencyScan.packageManagers.push(await this.runPipAudit(projectPath));
      }

      // Maven dependency check (if Java project)
      if (await this.fileExists(path.join(projectPath, 'pom.xml'))) {
        dependencyScan.packageManagers.push(await this.runMavenDependencyCheck(projectPath));
      }

      // Aggregate results
      for (const manager of dependencyScan.packageManagers) {
        if (manager.vulnerabilities) {
          dependencyScan.vulnerabilities.push(...manager.vulnerabilities);
        }
      }

      // Calculate metrics
      dependencyScan.metrics = {
        totalPackages: this.countTotalDependencies(dependencyScan.packageManagers),
        vulnerablePackages: this.countVulnerablePackages(dependencyScan.packageManagers),
        severityBreakdown: this.calculateSeverityBreakdown(dependencyScan.vulnerabilities),
        outdatedPackages: this.countOutdatedPackages(dependencyScan.packageManagers)
      };

      dependencyScan.duration = Date.now() - startTime;

    } catch (error) {
      dependencyScan.error = error.message;
    }

    return dependencyScan;
  }

  /**
   * Scan for secrets and credentials
   */
  async scanForSecrets(projectPath) {
    const secretsScan = {
      tools: [],
      findings: [],
      metrics: {},
      duration: 0
    };

    try {
      const startTime = Date.now();

      // git-secrets scan
      secretsScan.tools.push(await this.runGitSecretsScan(projectPath));

      // truffleHog scan
      secretsScan.tools.push(await this.runTruffleHogScan(projectPath));

      // Custom secret patterns
      secretsScan.tools.push(await this.runCustomSecretPatterns(projectPath));

      // Environment variable scanning
      secretsScan.tools.push(await this.scanEnvironmentVariables(projectPath));

      // Aggregate results
      for (const tool of secretsScan.tools) {
        if (tool.findings) {
          secretsScan.findings.push(...tool.findings);
        }
      }

      // Calculate metrics
      secretsScan.metrics = {
        totalTools: secretsScan.tools.length,
        totalFindings: secretsScan.findings.length,
        severityBreakdown: this.calculateSeverityBreakdown(secretsScan.findings),
        fileTypes: this.analyzeSecretFileTypes(secretsScan.findings)
      };

      secretsScan.duration = Date.now() - startTime;

    } catch (error) {
      secretsScan.error = error.message;
    }

    return secretsScan;
  }

  /**
   * Scan API endpoints for vulnerabilities
   */
  async scanApiEndpoints(projectPath) {
    const apiScan = {
      endpoints: [],
      vulnerabilities: [],
      metrics: {},
      duration: 0
    };

    try {
      const startTime = Date.now();

      // Discover API endpoints
      const endpoints = await this.discoverApiEndpoints(projectPath);
      apiScan.endpoints = endpoints;

      // Scan each endpoint
      for (const endpoint of endpoints) {
        const endpointScan = await this.scanApiEndpoint(endpoint);
        if (endpointScan.vulnerabilities) {
          apiScan.vulnerabilities.push(...endpointScan.vulnerabilities);
        }
      }

      // Calculate metrics
      apiScan.metrics = {
        totalEndpoints: endpoints.length,
        vulnerableEndpoints: this.countVulnerableEndpoints(apiScan.vulnerabilities, endpoints),
        severityBreakdown: this.calculateSeverityBreakdown(apiScan.vulnerabilities),
        securityScore: this.calculateApiSecurityScore(apiScan.vulnerabilities, endpoints.length)
      };

      apiScan.duration = Date.now() - startTime;

    } catch (error) {
      apiScan.error = error.message;
    }

    return apiScan;
  }

  /**
   * Run ESLint security scan
   */
  async runESLintSecurityScan(projectPath) {
    const scanResult = {
      engine: 'eslint-security',
      vulnerabilities: [],
      metrics: {}
    };

    try {
      const eslintConfig = {
        extends: ['plugin:security/recommended'],
        plugins: ['security'],
        rules: {
          'security/detect-object-injection': 'error',
          'security/detect-non-literal-regexp': 'error',
          'security/detect-unsafe-regex': 'error',
          'security/detect-buffer-noassert': 'error',
          'security/detect-child-process': 'error',
          'security/detect-disable-mustache-escape': 'error',
          'security/detect-eval-with-expression': 'error',
          'security/detect-new-buffer': 'error',
          'security/detect-no-csrf-before-method-override': 'error',
          'security/detect-non-literal-fs-filename': 'error',
          'security/detect-non-literal-require': 'error',
          'security/detect-possible-timing-attacks': 'error',
          'security/detect-pseudoRandomBytes': 'error'
        }
      };

      const eslintCommand = `cd ${projectPath} && npx eslint --format=json --config='${JSON.stringify(eslintConfig)}' .`;
      const output = execSync(eslintCommand, { encoding: 'utf8' });

      const results = JSON.parse(output);

      for (const file of results) {
        for (const message of file.messages) {
          if (message.severity === 2) { // Error
            scanResult.vulnerabilities.push({
              type: 'CODE_VULNERABILITY',
              engine: 'eslint',
              rule: message.ruleId,
              file: file.filePath,
              line: message.line,
              column: message.column,
              message: message.message,
              severity: this.mapESLintSeverity(message.ruleId),
              recommendation: this.getESLintRecommendation(message.ruleId)
            });
          }
        }
      }

      scanResult.metrics = {
        filesScanned: results.length,
        vulnerabilitiesFound: scanResult.vulnerabilities.length,
        rulesApplied: Object.keys(eslintConfig.rules).length
      };

    } catch (error) {
      // ESLint exits with non-zero code when issues found
      if (error.stdout) {
        try {
          const results = JSON.parse(error.stdout);
          // Process results as above
        } catch {
          scanResult.error = error.message;
        }
      } else {
        scanResult.error = error.message;
      }
    }

    return scanResult;
  }

  /**
   * Run npm audit
   */
  async runNpmAudit(projectPath) {
    const auditResult = {
      manager: 'npm',
      vulnerabilities: [],
      metrics: {}
    };

    try {
      const auditCommand = `cd ${projectPath} && npm audit --json`;
      const output = execSync(auditCommand, { encoding: 'utf8' });
      const auditData = JSON.parse(output);

      // Process vulnerabilities
      if (auditData.vulnerabilities) {
        for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities)) {
          auditResult.vulnerabilities.push({
            type: 'DEPENDENCY_VULNERABILITY',
            package: packageName,
            version: vulnData.via?.map(v => v.version || 'Unknown').join(', ') || 'Unknown',
            severity: vulnData.severity.toUpperCase(),
            title: vulnData.via?.[0]?.title || 'Security vulnerability',
            url: vulnData.via?.[0]?.url || '',
            fixAvailable: vulnData.fixAvailable,
            patchedIn: vulnData.fixAvailable?.version || null
          });
        }
      }

      auditResult.metrics = {
        totalVulnerabilities: auditData.metadata?.vulnerabilities?.total || 0,
        criticalVulnerabilities: auditData.metadata?.vulnerabilities?.critical || 0,
        highVulnerabilities: auditData.metadata?.vulnerabilities?.high || 0,
        moderateVulnerabilities: auditData.metadata?.vulnerabilities?.moderate || 0,
        lowVulnerabilities: auditData.metadata?.vulnerabilities?.low || 0,
        totalDependencies: Object.keys(auditData.vulnerabilities || {}).length
      };

    } catch (error) {
      // npm audit exits with non-zero code when vulnerabilities found
      try {
        if (error.stdout) {
          const auditData = JSON.parse(error.stdout);
          // Process audit data as above
        } else {
          auditResult.error = error.message;
        }
      } catch {
        auditResult.error = error.message;
      }
    }

    return auditResult;
  }

  /**
   * Run custom secret patterns
   */
  async runCustomSecretPatterns(projectPath) {
    const scanResult = {
      engine: 'custom-patterns',
      findings: [],
      metrics: {}
    };

    try {
      const secretPatterns = [
        {
          name: 'AWS Access Key',
          pattern: /AKIA[0-9A-Z]{16}/g,
          severity: 'CRITICAL',
          description: 'AWS access key detected'
        },
        {
          name: 'AWS Secret Key',
          pattern: /[0-9a-zA-Z/+]{40}/g,
          severity: 'CRITICAL',
          description: 'AWS secret key pattern detected'
        },
        {
          name: 'GitHub Token',
          pattern: /ghp_[a-zA-Z0-9]{36}/g,
          severity: 'CRITICAL',
          description: 'GitHub personal access token detected'
        },
        {
          name: 'Private Key',
          pattern: /-----BEGIN (?:RSA )?PRIVATE KEY-----/g,
          severity: 'CRITICAL',
          description: 'Private key detected'
        },
        {
          name: 'API Key',
          pattern: /['\"]?api[_-]?key['\"]?\s*[:=]\s*['\"]\w+['\"]/gi,
          severity: 'HIGH',
          description: 'API key detected'
        },
        {
          name: 'Database URL',
          pattern: /(?:mysql|postgresql|mongodb):\/\/[^\s'"]+/gi,
          severity: 'HIGH',
          description: 'Database connection string detected'
        },
        {
          name: 'Password in URL',
          pattern: /:\/\/[^:]+:[^@]+@/g,
          severity: 'HIGH',
          description: 'Password in URL detected'
        },
        {
          name: 'JWT Secret',
          pattern: /['\"]?jwt[_-]?secret['\"]?\s*[:=]\s*['\"]\w+['\"]/gi,
          severity: 'MEDIUM',
          description: 'JWT secret detected'
        }
      ];

      const files = await this.getAllSourceFiles(projectPath);

      for (const file of files) {
        const content = await fs.readFile(file, 'utf8');

        for (const pattern of secretPatterns) {
          const matches = content.match(pattern.pattern);
          if (matches) {
            for (const match of matches) {
              scanResult.findings.push({
                type: 'SECRET_DETECTED',
                pattern: pattern.name,
                file: file,
                line: this.findLineNumber(content, match),
                match: this.maskSensitiveData(match),
                severity: pattern.severity,
                description: pattern.description
              });
            }
          }
        }
      }

      scanResult.metrics = {
        filesScanned: files.length,
        patternsApplied: secretPatterns.length,
        totalFindings: scanResult.findings.length,
        severityBreakdown: this.calculateSeverityBreakdown(scanResult.findings)
      };

    } catch (error) {
      scanResult.error = error.message;
    }

    return scanResult;
  }

  /**
   * Calculate scan summary
   */
  async calculateScanSummary(results) {
    const summary = {
      totalVulnerabilities: 0,
      criticalIssues: 0,
      highIssues: 0,
      mediumIssues: 0,
      lowIssues: 0,
      securityScore: 100,
      scanResults: {},
      recommendations: []
    };

    // Aggregate all vulnerabilities
    const allVulnerabilities = [];

    for (const [category, result] of Object.entries(results)) {
      if (result.vulnerabilities) {
        allVulnerabilities.push(...result.vulnerabilities);
        summary.scanResults[category] = {
          vulnerabilities: result.vulnerabilities.length,
          status: result.vulnerabilities.length > 0 ? 'ISSUES_FOUND' : 'CLEAN'
        };
      }

      if (result.findings) {
        allVulnerabilities.push(...result.findings);
        summary.scanResults[category] = {
          vulnerabilities: result.findings.length,
          status: result.findings.length > 0 ? 'ISSUES_FOUND' : 'CLEAN'
        };
      }
    }

    // Count by severity
    summary.totalVulnerabilities = allVulnerabilities.length;

    for (const vuln of allVulnerabilities) {
      switch (vuln.severity) {
        case 'CRITICAL':
          summary.criticalIssues++;
          summary.securityScore -= 25;
          break;
        case 'HIGH':
          summary.highIssues++;
          summary.securityScore -= 15;
          break;
        case 'MEDIUM':
          summary.mediumIssues++;
          summary.securityScore -= 8;
          break;
        case 'LOW':
          summary.lowIssues++;
          summary.securityScore -= 3;
          break;
      }
    }

    summary.securityScore = Math.max(0, summary.securityScore);

    // Generate recommendations
    summary.recommendations = this.generateRecommendations(summary);

    // Determine overall status
    summary.status = this.determineOverallStatus(summary);

    return summary;
  }

  /**
   * Handle critical vulnerabilities
   */
  async handleCriticalVulnerabilities(scan) {
    const criticalVulns = [];

    // Collect all critical vulnerabilities
    for (const [category, result] of Object.entries(scan.results)) {
      if (result.vulnerabilities) {
        criticalVulns.push(...result.vulnerabilities.filter(v => v.severity === 'CRITICAL'));
      }
      if (result.findings) {
        criticalVulns.push(...result.findings.filter(f => f.severity === 'CRITICAL'));
      }
    }

    if (criticalVulns.length > 0) {
      console.log(`ðŸš¨ CRITICAL: ${criticalVulns.length} critical vulnerabilities found!`);

      // Emit critical vulnerability event
      this.emit('criticalVulnerabilitiesFound', {
        scanId: scan.id,
        vulnerabilities: criticalVulns
      });

      // Automated response actions
      if (this.config.enableAutoRemediation) {
        await this.performAutoRemediation(criticalVulns);
      }

      // Create security alert
      await this.createSecurityAlert('CRITICAL_VULNERABILITIES', {
        scanId: scan.id,
        count: criticalVulns.length,
        vulnerabilities: criticalVulns
      });
    }
  }

  /**
   * Generate scan report
   */
  async generateScanReport(scan) {
    const report = {
      metadata: {
        scanId: scan.id,
        timestamp: scan.timestamp,
        projectPath: scan.projectPath,
        type: scan.type,
        duration: scan.duration,
        version: '1.0'
      },
      summary: scan.summary,
      details: scan.results,
      recommendations: scan.summary.recommendations,
      compliance: await this.assessCompliance(scan)
    };

    try {
      const reportDir = path.join(__dirname, '../reports');
      await fs.mkdir(reportDir, { recursive: true });

      // Save in requested format
      if (this.config.reportFormat === 'json') {
        const reportFile = path.join(reportDir, `scan_report_${scan.id}.json`);
        await fs.writeFile(reportFile, JSON.stringify(report, null, 2));
      } else if (this.config.reportFormat === 'html') {
        const htmlReport = await this.generateHTMLReport(report);
        const reportFile = path.join(reportDir, `scan_report_${scan.id}.html`);
        await fs.writeFile(reportFile, htmlReport);
      }

      console.log(`ðŸ“„ Scan report generated: scan_report_${scan.id}.${this.config.reportFormat}`);

    } catch (error) {
      console.error('Failed to generate scan report:', error);
    }

    return report;
  }

  /**
   * Get vulnerability statistics
   */
  getVulnerabilityStatistics() {
    return {
      ...this.scanMetrics,
      recentScans: this.scanHistory.slice(-10),
      criticalTrend: this.calculateVulnerabilityTrend('CRITICAL'),
      vulnerabilityRate: this.scanMetrics.scansCompleted > 0
        ? (this.scanMetrics.vulnerabilitiesFound / this.scanMetrics.scansCompleted).toFixed(2)
        : '0'
    };
  }

  /**
   * Helper methods
   */
  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  maskSensitiveData(data) {
    if (data.length > 8) {
      return data.substring(0, 4) + '*'.repeat(data.length - 8) + data.substring(data.length - 4);
    }
    return '*'.repeat(data.length);
  }

  findLineNumber(content, match) {
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes(match)) {
        return i + 1;
      }
    }
    return 0;
  }

  calculateSeverityBreakdown(vulnerabilities) {
    const breakdown = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };

    for (const vuln of vulnerabilities) {
      if (breakdown[vuln.severity] !== undefined) {
        breakdown[vuln.severity]++;
      }
    }

    return breakdown;
  }

  generateScanId() {
    return `scan_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;
  }

  async getAllSourceFiles(projectPath) {
    const files = [];
    const extensions = ['.js', '.ts', '.jsx', '.tsx', '.json', '.yml', '.yaml', '.env', '.config'];

    async function scanDirectory(dir) {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
          await scanDirectory(fullPath);
        } else if (entry.isFile() && extensions.some(ext => entry.name.endsWith(ext))) {
          files.push(fullPath);
        }
      }
    }

    await scanDirectory(projectPath);
    return files;
  }

  mapESLintSeverity(ruleId) {
    const criticalRules = [
      'security/detect-object-injection',
      'security/detect-eval-with-expression',
      'security/detect-new-buffer'
    ];

    const highRules = [
      'security/detect-child-process',
      'security/detect-non-literal-require',
      'security/detect-non-literal-fs-filename'
    ];

    if (criticalRules.includes(ruleId)) return 'CRITICAL';
    if (highRules.includes(ruleId)) return 'HIGH';
    return 'MEDIUM';
  }

  getESLintRecommendation(ruleId) {
    const recommendations = {
      'security/detect-object-injection': 'Avoid using object property names in array constructors. Validate input properly.',
      'security/detect-eval-with-expression': 'Avoid using eval() with dynamic expressions. Use safer alternatives.',
      'security/detect-child-process': 'Validate and sanitize all inputs passed to child processes.',
      'security/detect-non-literal-require': 'Avoid dynamic require() calls. Use static imports or validate input.',
      'security/detect-non-literal-fs-filename': 'Validate and sanitize file paths. Use path.join() and check for directory traversal.'
    };

    return recommendations[ruleId] || 'Review the code for security implications and apply best practices.';
  }
}

module.exports = VulnerabilityScanner;